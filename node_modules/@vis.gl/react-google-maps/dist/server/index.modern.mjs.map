{"version":3,"file":"index.modern.mjs","sources":["../../src/libraries/create-static-maps-url/helpers.ts","../../src/libraries/create-static-maps-url/assemble-marker-params.ts","../../src/libraries/create-static-maps-url/assemble-path-params.ts","../../src/libraries/create-static-maps-url/assemble-map-type-styles.ts","../../src/libraries/create-static-maps-url/index.ts","../../src/components/static-map.tsx"],"sourcesContent":["import {StaticMapsLocation} from './types';\n\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */\nexport function formatLocation(location: StaticMapsLocation): string {\n  return typeof location === 'string'\n    ? location\n    : `${location.lat},${location.lng}`;\n}\n\n// Used for removing the leading pipe from the param string\nexport function formatParam(string: string) {\n  return string.slice(1);\n}\n","import {formatParam} from './helpers';\nimport {StaticMapsMarker} from './types';\n\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */\nexport function assembleMarkerParams(markers: StaticMapsMarker[] = []) {\n  const markerParams: Array<string> = [];\n\n  // Group markers by style\n  const markersByStyle = markers?.reduce(\n    (styles, marker) => {\n      const {color = 'red', label, size, scale, icon, anchor} = marker;\n\n      // Create a unique style key based on either icon properties or standard marker properties\n      const relevantProps = icon ? [icon, anchor, scale] : [color, label, size];\n      const key = relevantProps.filter(Boolean).join('-');\n\n      styles[key] = styles[key] || [];\n      styles[key].push(marker);\n      return styles;\n    },\n    {} as Record<string, StaticMapsMarker[]>\n  );\n\n  Object.values(markersByStyle ?? {}).forEach(markers => {\n    let markerParam: string = '';\n\n    const {icon} = markers[0];\n\n    // Create marker style from first marker in group since all markers share the same style.\n    Object.entries(markers[0]).forEach(([key, value]) => {\n      // Determine which properties to include based on whether marker uses custom icon\n      const relevantKeys = icon\n        ? ['icon', 'anchor', 'scale']\n        : ['color', 'label', 'size'];\n\n      if (relevantKeys.includes(key)) {\n        markerParam += `|${key}:${value}`;\n      }\n    });\n\n    // Add location coordinates for each marker in the style group\n    // Handles both string locations and lat/lng object formats.\n    for (const marker of markers) {\n      const location =\n        typeof marker.location === 'string'\n          ? marker.location\n          : `${marker.location.lat},${marker.location.lng}`;\n\n      markerParam += `|${location}`;\n    }\n\n    markerParams.push(markerParam);\n  });\n\n  return markerParams.map(formatParam);\n}\n","import {formatLocation, formatParam} from './helpers';\nimport {StaticMapsPath} from './types';\n\n/**\n * Assembles path parameters for the Static Maps Api from an array of paths.\n *\n * This function groups paths by their style properties (color, weight, fillcolor, geodesic)\n * and then constructs a string of path parameters for each group. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * Output: [\n *    'color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284'\n *  ]\n */\nexport function assemblePathParams(paths: Array<StaticMapsPath> = []) {\n  const pathParams: Array<string> = [];\n\n  // Group paths by their style properties (color, weight, fillcolor, geodesic)\n  // to combine paths with identical styles into single parameter strings\n  const pathsByStyle = paths?.reduce(\n    (styles, path) => {\n      const {color = 'default', weight, fillcolor, geodesic} = path;\n\n      // Create unique key for this style combination\n      const key = [color, weight, fillcolor, geodesic]\n        .filter(Boolean)\n        .join('-');\n\n      styles[key] = styles[key] || [];\n      styles[key].push(path);\n      return styles;\n    },\n    {} as Record<string, Array<StaticMapsPath>>\n  );\n\n  // Process each group of paths with identical styles\n  Object.values(pathsByStyle ?? {}).forEach(paths => {\n    let pathParam = '';\n\n    // Build style parameter string using properties from first path in group\n    // since all paths in this group share the same style\n    Object.entries(paths[0]).forEach(([key, value]) => {\n      if (['color', 'weight', 'fillcolor', 'geodesic'].includes(key)) {\n        pathParam += `|${key}:${value}`;\n      }\n    });\n\n    // Add location for all marker in style group\n    for (const path of paths) {\n      if (typeof path.coordinates === 'string') {\n        pathParam += `|${decodeURIComponent(path.coordinates)}`;\n      } else {\n        for (const location of path.coordinates) {\n          pathParam += `|${formatLocation(location)}`;\n        }\n      }\n    }\n\n    pathParams.push(pathParam);\n  });\n\n  return pathParams.map(formatParam);\n}\n","import {formatParam} from './helpers';\n\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */\nexport function assembleMapTypeStyles(\n  styles: Array<google.maps.MapTypeStyle>\n): string[] {\n  return styles\n    .map((mapTypeStyle: google.maps.MapTypeStyle) => {\n      const {featureType, elementType, stylers = []} = mapTypeStyle;\n\n      let styleString = '';\n\n      if (featureType) {\n        styleString += `|feature:${featureType}`;\n      }\n\n      if (elementType) {\n        styleString += `|element:${elementType}`;\n      }\n\n      for (const styler of stylers) {\n        Object.entries(styler).forEach(([name, value]) => {\n          styleString += `|${name}:${String(value).replace('#', '0x')}`;\n        });\n      }\n\n      return styleString;\n    })\n    .map(formatParam);\n}\n","import {assembleMarkerParams} from './assemble-marker-params';\nimport {assemblePathParams} from './assemble-path-params';\nimport {formatLocation} from './helpers';\n\nimport {StaticMapsApiOptions} from './types';\nimport {assembleMapTypeStyles} from './assemble-map-type-styles';\n\nconst STATIC_MAPS_BASE = 'https://maps.googleapis.com/maps/api/staticmap';\n\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */\nexport function createStaticMapsUrl({\n  apiKey,\n  width,\n  height,\n  center,\n  zoom,\n  scale,\n  format,\n  mapType,\n  language,\n  region,\n  mapId,\n  markers = [],\n  paths = [],\n  visible = [],\n  style = []\n}: StaticMapsApiOptions) {\n  if (!apiKey) {\n    console.warn('API key is required');\n  }\n  if (!width || !height) {\n    console.warn('Width and height are required');\n  }\n\n  const params: Record<string, string | number | null> = {\n    key: apiKey,\n    size: `${width}x${height}`,\n    ...(center && {center: formatLocation(center)}),\n    ...(zoom && {zoom}),\n    ...(scale && {scale}),\n    ...(format && {format}),\n    ...(mapType && {maptype: mapType}),\n    ...(language && {language}),\n    ...(region && {region}),\n    ...(mapId && {map_id: mapId})\n  };\n\n  const url = new URL(STATIC_MAPS_BASE);\n\n  // Params that don't need special handling\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.append(key, String(value));\n  });\n\n  // Assemble Markers\n  for (const markerParam of assembleMarkerParams(markers)) {\n    url.searchParams.append('markers', markerParam);\n  }\n\n  // Assemble Paths\n  for (const pathParam of assemblePathParams(paths)) {\n    url.searchParams.append('path', pathParam);\n  }\n\n  // Assemble visible locations\n  if (visible.length) {\n    url.searchParams.append(\n      'visible',\n      visible.map(location => formatLocation(location)).join('|')\n    );\n  }\n\n  // Assemble Map Type Styles\n  for (const styleString of assembleMapTypeStyles(style)) {\n    url.searchParams.append('style', styleString);\n  }\n\n  return url.toString();\n}\n","import React from 'react';\n\nexport {createStaticMapsUrl} from '../libraries/create-static-maps-url';\nexport * from '../libraries/create-static-maps-url/types';\n\n/**\n * Props for the StaticMap component\n */\nexport type StaticMapProps = {\n  url: string;\n  className?: string;\n};\n\nexport const StaticMap = (props: StaticMapProps) => {\n  const {url, className} = props;\n\n  if (!url) throw new Error('URL is required');\n\n  return <img className={className} src={url} width=\"100%\" />;\n};\n"],"names":["formatLocation","location","lat","lng","formatParam","string","slice","assembleMarkerParams","markers","markerParams","markersByStyle","reduce","styles","marker","color","label","size","scale","icon","anchor","relevantProps","key","filter","Boolean","join","push","Object","values","forEach","markerParam","entries","value","relevantKeys","includes","map","assemblePathParams","paths","pathParams","pathsByStyle","path","weight","fillcolor","geodesic","pathParam","coordinates","decodeURIComponent","assembleMapTypeStyles","mapTypeStyle","featureType","elementType","stylers","styleString","styler","name","String","replace","STATIC_MAPS_BASE","createStaticMapsUrl","apiKey","width","height","center","zoom","format","mapType","language","region","mapId","visible","style","console","warn","params","_extends","maptype","map_id","url","URL","searchParams","append","length","toString","StaticMap","props","className","Error","React","createElement","src"],"mappings":"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"}